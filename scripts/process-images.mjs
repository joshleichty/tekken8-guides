/**
 * Image Processing Script for Character Portraits
 * 
 * This script:
 * 1. Crops the top-left quadrant from each original image
 * 2. Generates optimized WebP images at multiple sizes
 * 3. Creates PNG fallbacks for compatibility
 * 
 * Run with: node scripts/process-images.mjs
 */

import sharp from 'sharp';
import { readdir, mkdir } from 'fs/promises';
import { join, basename, extname } from 'path';

const ORIGINALS_DIR = './originals';
const OUTPUT_DIR = './public/characters';

// Output sizes (width in pixels)
// These cover common use cases:
// - 128: Thumbnails, small icons
// - 256: Cards, grid views
// - 512: Detail views, larger cards
// - 1024: Full-size display, retina support
const SIZES = [128, 256, 512, 1024];

// WebP quality (80 is a good balance of quality/size)
const WEBP_QUALITY = 80;

// PNG compression level (0-9, higher = smaller but slower)
const PNG_COMPRESSION = 9;

// Special layout configurations for images that aren't 2x3 grids
// cols: 1, rows: 1 means no grid - use the full image
const SPECIAL_LAYOUTS = {
  'clive-rosfield': { cols: 2, rows: 1 }, // Just left/right versions
  'armor-king': { cols: 1, rows: 1 },     // Single portrait, no grid
  'fahkumram': { cols: 1, rows: 1 },      // Single portrait, no grid
};

async function processImage(inputPath, filename) {
  const slug = basename(filename, extname(filename));
  const outputSubdir = join(OUTPUT_DIR, slug);
  
  // Create output directory for this character
  await mkdir(outputSubdir, { recursive: true });
  
  // Load the original image and get metadata
  const image = sharp(inputPath);
  const metadata = await image.metadata();
  
  // Get layout configuration (default is 2 columns x 3 rows)
  const layout = SPECIAL_LAYOUTS[slug] || { cols: 2, rows: 3 };
  
  // Calculate the top-left quadrant dimensions
  const quadrantWidth = Math.floor(metadata.width / layout.cols);
  const quadrantHeight = Math.floor(metadata.height / layout.rows);
  
  // For single image (1x1), no cropping needed
  // For single-row layouts (nx1), account for watermark bar at bottom (~100px)
  // For grid layouts, small margin to avoid divider lines
  const isFullImage = layout.cols === 1 && layout.rows === 1;
  const heightAdjust = isFullImage ? 0 : (layout.rows === 1 ? 100 : 2);
  const widthAdjust = isFullImage ? 0 : 2;
  
  // Extract the top-left quadrant (or full image if 1x1)
  const cropped = image.extract({
    left: 0,
    top: 0,
    width: quadrantWidth - widthAdjust,
    height: quadrantHeight - heightAdjust,
  });
  
  // Get the cropped image buffer to reuse
  const croppedBuffer = await cropped.toBuffer();
  
  console.log(`Processing ${slug} (${quadrantWidth}x${quadrantHeight})...`);
  
  // Generate each size
  for (const size of SIZES) {
    // Calculate height maintaining aspect ratio
    const aspectRatio = (quadrantHeight - 2) / (quadrantWidth - 2);
    const height = Math.round(size * aspectRatio);
    
    // Create resized sharp instance
    const resized = sharp(croppedBuffer).resize(size, height, {
      fit: 'contain',
      background: { r: 0, g: 0, b: 0, alpha: 0 },
    });
    
    // Generate WebP (primary format - best compression)
    await resized
      .clone()
      .webp({ quality: WEBP_QUALITY })
      .toFile(join(outputSubdir, `${size}.webp`));
    
    // Generate PNG (fallback)
    await resized
      .clone()
      .png({ compressionLevel: PNG_COMPRESSION })
      .toFile(join(outputSubdir, `${size}.png`));
  }
  
  console.log(`  âœ“ Generated ${SIZES.length * 2} images for ${slug}`);
}

async function main() {
  console.log('ðŸ–¼ï¸  Character Image Processor\n');
  
  // Create output directory
  await mkdir(OUTPUT_DIR, { recursive: true });
  
  // Get all PNG files from originals
  const files = await readdir(ORIGINALS_DIR);
  const pngFiles = files.filter(f => f.toLowerCase().endsWith('.png'));
  
  console.log(`Found ${pngFiles.length} original images\n`);
  
  // Process each image
  for (const file of pngFiles) {
    try {
      await processImage(join(ORIGINALS_DIR, file), file);
    } catch (error) {
      console.error(`  âœ— Error processing ${file}:`, error.message);
    }
  }
  
  // Generate a manifest file for easy imports
  const manifest = {};
  for (const file of pngFiles) {
    const slug = basename(file, extname(file));
    manifest[slug] = {
      sizes: SIZES,
      formats: ['webp', 'png'],
      basePath: `/characters/${slug}`,
    };
  }
  
  // Write manifest
  const manifestContent = `// Auto-generated by scripts/process-images.mjs
// Do not edit manually

export const characterImages = ${JSON.stringify(manifest, null, 2)} as const;

export type CharacterSlug = keyof typeof characterImages;

export function getCharacterImageSrc(slug: CharacterSlug, size: 128 | 256 | 512 | 1024 = 256): string {
  return \`/characters/\${slug}/\${size}.webp\`;
}

export function getCharacterImageSrcSet(slug: CharacterSlug): string {
  const sizes = [128, 256, 512, 1024] as const;
  return sizes
    .map(size => \`/characters/\${slug}/\${size}.webp \${size}w\`)
    .join(', ');
}
`;
  
  await mkdir('./src/assets', { recursive: true });
  const { writeFile } = await import('fs/promises');
  await writeFile('./src/assets/character-images.ts', manifestContent);
  
  console.log('\nâœ… Processing complete!');
  console.log(`   Output: ${OUTPUT_DIR}/`);
  console.log(`   Manifest: src/assets/character-images.ts`);
}

main().catch(console.error);
